#pragma once

#include <functional>
#include <mutex>
#include <utility>

namespace libhoard {


template<typename Functor>
inline resolver_policy<Functor>::resolver_policy() = default;

template<typename Functor>
inline resolver_policy<Functor>::resolver_policy(Functor resolver)
: resolver_(std::move(resolver))
{}


template<typename Functor>
template<typename HashTable, typename ValueType, typename Allocator>
template<typename... Args>
inline resolver_policy<Functor>::table_base<HashTable, ValueType, Allocator>::table_base(const std::tuple<Args...>& args, [[maybe_unused]] const Allocator& alloc)
: resolver_(std::get<resolver_policy>(args).resolver_)
{}

template<typename Functor>
template<typename HashTable, typename ValueType, typename Allocator>
template<typename... Keys>
inline auto resolver_policy<Functor>::table_base<HashTable, ValueType, Allocator>::resolve(std::size_t hash, const Keys&... keys) -> detail::refcount_ptr<ValueType, Allocator> {
  auto self = static_cast<HashTable*>(this);
  auto new_value = self->allocate_value_type(std::piecewise_construct, std::forward_as_tuple(keys...), std::invoke(resolver_, keys...));
  self->link(hash, new_value);
  return new_value;
}


template<typename Functor>
inline async_resolver_policy<Functor>::async_resolver_policy(Functor resolver)
: resolver_(std::move(resolver))
{}

template<typename Functor>
template<typename HashTable, typename ValuePointer>
inline auto async_resolver_policy<Functor>::on_assign_(HashTable& hashtable, ValuePointer value_pointer, bool value, bool assigned_via_callback) noexcept -> void {
  hashtable.on_assign_(value_pointer, value, assigned_via_callback);
}


template<typename Functor>
template<typename HashTable, typename ValueType, typename Allocator>
template<typename... Args>
inline async_resolver_policy<Functor>::table_base<HashTable, ValueType, Allocator>::table_base(const std::tuple<Args...>& args, [[maybe_unused]] const Allocator& alloc)
: resolver_(std::get<async_resolver_policy>(args).resolver_)
{}

template<typename Functor>
template<typename HashTable, typename ValueType, typename Allocator>
template<typename... Keys>
inline auto async_resolver_policy<Functor>::table_base<HashTable, ValueType, Allocator>::async_resolve(std::size_t hash, const Keys&... keys) -> detail::refcount_ptr<ValueType, Allocator> {
  using callback_allocator_type = typename std::allocator_traits<Allocator>::template rebind_alloc<callback>;

  auto self = static_cast<HashTable*>(this);
  auto new_value = self->allocate_value_type(std::piecewise_construct, std::forward_as_tuple(keys...));

  const std::shared_ptr<callback> callback_ptr = std::allocate_shared<callback>(callback_allocator_type(self->get_allocator()), self->shared_from_this(), new_value);
  resolver_(callback_ptr, keys...);

  self->link(hash, new_value);
  return new_value;
}


template<typename Functor>
template<typename HashTable, typename ValueType, typename Allocator>
inline async_resolver_policy<Functor>::table_base<HashTable, ValueType, Allocator>::callback::callback(const std::shared_ptr<HashTable>& self, detail::refcount_ptr<ValueType, Allocator> value)
: weak_self(self),
  value(std::move(value))
{}

template<typename Functor>
template<typename HashTable, typename ValueType, typename Allocator>
inline async_resolver_policy<Functor>::table_base<HashTable, ValueType, Allocator>::callback::~callback() {
  cancel();
}

template<typename Functor>
template<typename HashTable, typename ValueType, typename Allocator>
template<typename... Args>
inline auto async_resolver_policy<Functor>::table_base<HashTable, ValueType, Allocator>::callback::assign(Args&&... args) -> bool {
  if (called) return false;

  if (auto self = weak_self.lock()) {
    std::lock_guard<HashTable> lck{ *self };
    value->assign(std::forward<Args>(args)...);
    on_assign_(*self, value.get(), true, true);
    called = true;
    return true;
  } else {
    if (auto pending = value->get_pending()) pending->cancel();
    called = true;
    return false;
  }
}

template<typename Functor>
template<typename HashTable, typename ValueType, typename Allocator>
inline auto async_resolver_policy<Functor>::table_base<HashTable, ValueType, Allocator>::callback::assign_error(typename ValueType::error_type ex) noexcept -> bool {
  if (called) return false;

  if (auto self = weak_self.lock()) {
    std::lock_guard<HashTable> lck{ *self };
    value->assign_error(std::move(ex));
    on_assign_(*self, value.get(), false, true);
    called = true;
    return true;
  } else {
    if (auto pending = value->get_pending()) pending->cancel();
    called = true;
    return false;
  }
}

template<typename Functor>
template<typename HashTable, typename ValueType, typename Allocator>
inline auto async_resolver_policy<Functor>::table_base<HashTable, ValueType, Allocator>::callback::cancel() noexcept -> bool {
  if (called) return false;

  if (auto self = weak_self.lock()) {
    std::lock_guard<HashTable> lck{ *self };
    value->cancel();
  } else if (auto pending = value->get_pending()) {
    pending->cancel();
  }
  called = true;
  return true;
}


} /* namespace libhoard */
